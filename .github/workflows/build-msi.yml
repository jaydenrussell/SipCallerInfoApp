
name: Build MSI (WinUI 3 + WiX v3)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build-msi:
    runs-on: windows-latest

    env:
      # Keep this GUID constant across releases (major upgrade detection depends on it)
      UPGRADE_CODE: "{E3A1C4F5-1234-4B7D-9D2B-ABCD12345678}"

      # Deterministic publish output inside workspace
      PUBLISH_OUT: "${{ github.workspace }}\\publish-win-x64"

      # Your repo has a top-level 'installer' folder
      INSTALLER_DIR: "${{ github.workspace }}\\installer"
      MSI_OUTPUT: "${{ github.workspace }}\\installer\\SipCallerInfoApp.msi"

      # Optional: pin the csproj to avoid auto-detect ambiguity
      # Uncomment and set to your actual project path if needed:
      # CSPROJ_PATH: "${{ github.workspace }}\\src\\SipCallerInfoApp\\SipCallerInfoApp.csproj"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Detect .sln or .csproj (skip if CSPROJ_PATH is set)
        if: ${{ env.CSPROJ_PATH == '' }}
        shell: pwsh
        run: |
          $root = $env:GITHUB_WORKSPACE
          $sln = Get-ChildItem -Path $root -Recurse -Filter *.sln | Select-Object -First 1
          $csproj = $null
          if (-not $sln) { $csproj = Get-ChildItem -Path $root -Recurse -Filter *.csproj | Select-Object -First 1 }
          if (-not $sln -and -not $csproj) { Write-Error "No .sln or .csproj found." }
          if ($sln) {
            "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            Write-Host "Detected solution: $($sln.FullName)"
          } else {
            "CSPROJ_PATH=$($csproj.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            Write-Host "Detected project: $($csproj.FullName)"
          }

      - name: Clean & Restore
        shell: pwsh
        run: |
          if ($env:SLN_PATH) { dotnet clean "$env:SLN_PATH"; dotnet restore "$env:SLN_PATH" }
          elseif ($env:CSPROJ_PATH) { dotnet clean "$env:CSPROJ_PATH"; dotnet restore "$env:CSPROJ_PATH" }
          else { Write-Error "Neither SLN_PATH nor CSPROJ_PATH is set."; exit 1 }

      - name: Publish (self-contained, disable XAML-generated Main)
        shell: pwsh
        run: |
          if (Test-Path $env:PUBLISH_OUT) { Remove-Item $env:PUBLISH_OUT -Recurse -Force }
          New-Item -ItemType Directory -Path $env:PUBLISH_OUT | Out-Null

          if ($env:CSPROJ_PATH) {
            dotnet publish "$env:CSPROJ_PATH" `
              -c Release -r win-x64 --self-contained true `
              -p:DefineConstants=DISABLE_XAML_GENERATED_MAIN `
              -p:PublishSingleFile=false -p:IncludeNativeLibrariesForSelfExtract=false `
              -o "$env:PUBLISH_OUT"
          } else {
            $firstProj = Get-ChildItem -Path (Split-Path $env:SLN_PATH) -Recurse -Filter *.csproj | Select-Object -First 1
            if (-not $firstProj) { Write-Error "No .csproj found to publish."; exit 1 }
            dotnet publish "$($firstProj.FullName)" `
              -c Release -r win-x64 --self-contained true `
              -p:DefineConstants=DISABLE_XAML_GENERATED_MAIN `
              -p:PublishSingleFile=false -p:IncludeNativeLibrariesForSelfExtract=false `
              -o "$env:PUBLISH_OUT"
          }

      - name: Verify publish output
        shell: pwsh
        run: |
          if (-not (Test-Path "$env:PUBLISH_OUT")) {
            Write-Error "Publish output folder not found: $env:PUBLISH_OUT."
          }
          $files = Get-ChildItem "$env:PUBLISH_OUT" -Recurse -File
          if ($files.Count -eq 0) {
            Write-Error "Publish output is empty: $env:PUBLISH_OUT. Check dotnet publish logs."
          } else {
            Write-Host "Publish output contains $($files.Count) files."
            $files | Select-Object -First 20 | Format-Table FullName
          }

      - name: Install WiX Toolset v3 via Chocolatey
        shell: pwsh
        run: |
          choco install wixtoolset -y
          $wixBin = "C:\Program Files (x86)\WiX Toolset v3.14\bin"
          if (-not (Test-Path $wixBin)) { Write-Error "WiX bin not found: $wixBin" }
          "WIXBIN=$wixBin" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "WIXBIN set to: $wixBin"
          Get-ChildItem "$wixBin" | Select-Object Name,Length | Format-Table

      - name: List installer dir (debug)
        shell: pwsh
        run: |
          Write-Host "Workspace: $env:GITHUB_WORKSPACE"
          Get-ChildItem "$env:INSTALLER_DIR" -Recurse | Format-Table FullName

      - name: Verify WiX authoring exists
        shell: pwsh
        run: |
          $wxs = Join-Path $env:INSTALLER_DIR "SipCallerInfoApp.wxs"
          if (-not (Test-Path $wxs)) {
            Write-Error "Missing $wxs. Ensure your authoring is committed under /installer/"
          } else {
            Write-Host "Found WiX authoring: $wxs"
          }


      
      - name: Prune satellites from publish folder (remove *.mui*)
        shell: pwsh
        run: |
          $pub = "$env:PUBLISH_OUT"
          if (-not (Test-Path $pub)) { Write-Error "Publish folder missing: $pub"; exit 1 }
      
          $mui = Get-ChildItem $pub -Recurse -File -Include *.mui, *.mui_* -ErrorAction SilentlyContinue
          $count = ($mui | Measure-Object).Count
          if ($count -gt 0) {
            Write-Host "Removing $count satellite files (*.mui*):"
            $mui | Select-Object -First 10 | ForEach-Object { Write-Host "  $_" }
            $mui | Remove-Item -Force
          } else {
            Write-Host "No *.mui* satellites found in publish folder."
          }

          

      - name: Harvest publish folder with Heat (suppress SelfReg)
        shell: pwsh
        run: |
          & "$env:WIXBIN\heat.exe" dir "$env:PUBLISH_OUT" `
            -cg SipCallerInfoAppComponents `
            -dr INSTALLFOLDER `
            -var var.PublishDir `
            -sfrag -srd -suid -sreg `
            -gg `
            -o "$env:INSTALLER_DIR\SipCallerInfoApp.Components.wxs"

      
      
      
      - name: Sanitize harvested fragment (remove .mui & Language attrs; verify)
        shell: pwsh
        run: |
          $frag = Join-Path $env:INSTALLER_DIR "SipCallerInfoApp.Components.wxs"
          if (-not (Test-Path $frag)) { Write-Error "Missing $frag"; exit 1 }
      
          # Read entire file; Heat often outputs single-line XML
          $text = Get-Content $frag -Raw
      
          # --- Pre-sanitize counts ---
          $preLang = [Regex]::Matches($text, 'Language="[^"]*"', 'IgnoreCase').Count
          $preMui1 = [Regex]::Matches($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*/>', 'IgnoreCase').Count
          $preMui2 = [Regex]::Matches($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*>.*?</File>', 'IgnoreCase, Singleline').Count
          Write-Host "Pre-sanitize: Language=$preLang; .mui self-close=$preMui1; .mui blocks=$preMui2"
      
          # --- Remove all Language="..." attributes ---
          $text = [Regex]::Replace($text, '(\sLanguage="[^"]*")', '', 'IgnoreCase, Singleline')
      
          # --- Remove all .mui files (self-closing and block forms) ---
          $text = [Regex]::Replace($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*/>', '', 'IgnoreCase, Singleline')
          $text = [Regex]::Replace($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*>.*?</File>', '', 'IgnoreCase, Singleline')
      
          # --- Write back as UTF-8 (no BOM) ---
          $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
          [System.IO.File]::WriteAllText($frag, $text, $utf8NoBom)
      
          # --- Post-sanitize verification ---
          $postLang = [Regex]::Matches($text, 'Language="[^"]*"', 'IgnoreCase').Count
          $postMui1 = [Regex]::Matches($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*/>', 'IgnoreCase').Count
          $postMui2 = [Regex]::Matches($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*>.*?</File>', 'IgnoreCase, Singleline').Count
          Write-Host "Post-sanitize: Language=$postLang; .mui self-close=$postMui1; .mui blocks=$postMui2"
      
          # Fail if anything remains
          if ($postLang -gt 0 -or $postMui1 -gt 0 -or $postMui2 -gt 0) {
            Write-Host "Sample remaining matches:"
            $m1 = [Regex]::Matches($text, 'Language="[^"]*"', 'IgnoreCase') | Select-Object -First 3
            $m2 = [Regex]::Matches($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*/>', 'IgnoreCase') | Select-Object -First 3
            $m3 = [Regex]::Matches($text, '<File\b[^>]*Name="[^"]*\.mui[^"]*"[^>]*>.*?</File>', 'IgnoreCase, Singleline') | Select-Object -First 3
            $m1 | ForEach-Object { Write-Host "  Language: $($_.Value)" }
            $m2 | ForEach-Object { Write-Host "  .mui self-close: $($_.Value)" }
            $m3 | ForEach-Object { Write-Host "  .mui block: $($_.Value.Substring(0, [Math]::Min(200, $_.Value.Length)))..." }
            Write-Error "Sanitize failed: remaining Language/.mui entries detected."
          } else {
            Write-Host "Sanitize OK â€” fragment is clean."
          }




      - name: Compile (candle)
        shell: pwsh
        run: |
          & "$env:WIXBIN\candle.exe" `
            -dPublishDir="$env:PUBLISH_OUT" `
            -dUpgradeCode="$env:UPGRADE_CODE" `
            -out "$env:INSTALLER_DIR\" `
            "$env:INSTALLER_DIR\SipCallerInfoApp.wxs" `
            "$env:INSTALLER_DIR\SipCallerInfoApp.Components.wxs"

      - name: Link (light)
        shell: pwsh
        run: |
          & "$env:WIXBIN\light.exe" `
            -ext WixUIExtension `
            -cultures:en-us `
            -out "$env:MSI_OUTPUT" `
            "$env:INSTALLER_DIR\SipCallerInfoApp.wixobj" `
            "$env:INSTALLER_DIR\SipCallerInfoApp.Components.wixobj"

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: SipCallerInfoApp-MSI
          path: ${{ env.MSI_OUTPUT }}
          if-no-files-found: error
